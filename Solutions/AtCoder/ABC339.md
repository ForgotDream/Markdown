## A

简单模拟即可。

注意到可以使用标准库中的 `std::find` 与反向迭代器来简化代码。

## B

使用二维数组模拟题目中过程即可！

## C

考虑先求出出发时车上最少有多少人，再把每次变化累加上去就行了！

问题转化为如何求出出发时车上有多少人。

由于车上的人数始终是非负的，我们可以考虑模拟上下车的这个过程。初始化车上的人数为 0，每次下车时，如果发现当前车上的人数不够多，则说明出发时的人数少了，我们将少的这部分补上即可。

容易做到 $\mathcal{O}(n)$ 时空复杂度。

## D

$N$ 的范围很小，我们考虑 BFS。

将两名玩家的位置记为 $(x1, y1)$ 与 $(x2, y2)$，则搜索的状态即为 $(x1, y1, x2, y2)$ 四元组。

转移是较为简单的。我们考虑每次枚举四个方向尝试移动，如果发现撞墙了就不动，否则改变坐标，转移到下一个状态。

由于 $N \le 60$，因此状态数 $|S| <= N^4 <= 12,960,000$，是完全可接受的！

## E

我们考虑一个朴素的 DP。设 $f_i$ 为以第 $i$ 个数结尾的满足题目要求的最长子序列长度，则我们可以很容易的得到转移：

$$
f_i = \max_{1 \le j \le i \land |a_i - a_j| \le D} f_j + 1
$$

这个方程直接做显然是 $\mathcal{O}(n^2)$ 的，但是我们可以发现，对于相同的 $a_i$，满足条件的 $a_j$ 都是位于某特定区间内的，也就是说，我们只需要快速得到对于某个区间内的 $a_i$ 其对应的 $f_i$ 最大值，也就是是一个单点修改，区间查询最大值的问题，这是容易用线段树解决的。

时间复杂度 $\mathcal{O}(n \log n)$。

## F

### 法一

我讨厌高精度，所以我用 pypy 草过去了。

### 法二

我还是很讨厌高精度，但是我也不咋喜欢 Python。因此我们这次用点不同的方法过掉这道题。

直接算复杂度肯定是不好的，有差不多 $\mathcal{O}(N^2 (\log A)^2)$，一眼过不掉。

数字太大了，受不了了，因此我们可以考虑在模意义下进行运算！设我们取的模数为 $p$，则我们认为，满足 $A_i \cdot A_j \equiv A_k \pmod{p}$ 这个关系的即为答案，这当然是不对的，但这个做法是不是就一定没前途呢？我们可以计算一下出现误判的概率是多少。

容易得到在 $A$ 的值域内 $\bmod p$ 同余的数约有 $\frac{10^{1000}}{p}$ 个。也就是说，对于一个确定的 $(A_i, A_j, A_k)$ 三元组，与其冲突的三元组约有 $\frac{10^{3000}}{p}$ 个。这是不是有点太多了？

没关系，如果一个模数会产生的冲突太多的话，我们可以多选几个啊！假定我们选定的模数集合为 $P$，且两两互质，则我们容易得到，这种情况下对于一个三元组与其冲突的个数即为 $\frac{10^{3000}}{\prod_{p \in P} p}$ 个了。如果我们取较多的均匀大质数作为模数，那么冲突的概率就相当低了。

设取了 $S$ 个模数，则时间复杂度为 $\mathcal{O}(S \cdot n^2)$。

## G

主席树板子（
