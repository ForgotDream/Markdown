## P3551

挺不错的一道题，感觉比较类似 P4824 那个题？

思路大概就是，将当前字符存到一个栈中，若当前栈顶的前 $k + 1$ 个元素刚好有 $1$ 个白色，就将这 $k$ 个元素弹出来。正确性是非常不证自明的。时空复杂度线性。

## P3594

答案肯定是一段区间内删除 $d$ 个构成的，那么显然答案不会小于 $d$。而答案的单调性应该也不难看出（且很好证明），于是我们考虑双指针，利用数据结构维护 $i \in [1, n - d + 1], \sum_{i \le j \le i + d - 1} w_j$ 的最大值，然后就跟普通的滑动窗口一样做就行了，每次滑动时减去当前区间内的长度为 $d$ 的区间的最大值即可。选取合适的数据结构就可以做到 $\mathcal{O}(n \log n)$。

更好的做法是，利用单调队列来维护这个区间最大值，这样就可以做到线性了。

## P1972

这题做法太多了。首先他是一道 莫队 的模板题，直接套上普通莫队就很容易做到 $\mathcal{O}(n \sqrt n)$，但我们在这里不提这种做法，而是介绍另一种 “区间数颜色” 类问题的做法。

区间数颜色是无法直接通过类似数点的手段来做的，但是作为学数据结构学傻了的人，我们考虑如何将其转化为一个数点的问题。

一种很好的做法是，我们考虑对每个颜色，维护这个颜色上一次出现的位置，称为它的 “前驱” ，并且我们规定第一次出现的颜色的前驱是 $0$。然后对于每一个询问 $[l, r]$，我们考虑某种颜色 $i$ 在区间内第一次出现的位置，那么此时显然有它的前驱所在的位置 $pre_i < l$。那么此时，区间内的颜色数量就等价于 $i \in [l, r] \land pre_i < l$ 的点的数量，是一个很标准的二维数点，这样这个问题是不是就迎刃而解了？我们直接考虑树套树就可以做到 $\mathcal{O}(n \log^2 n)$ 且强制在线了，并且甚至还能做单点修改。

但是树套树太难写了，我们考虑一些经典的套路，将询问离线，然后按照右端点排序，剩下的就全部都是板子了，我们考虑双指针加上 BIT 就可以做到 $\mathcal{O}(n \log n)$！

分块能不能做呢？答案是肯定的。直接分块的话，还必须得用一个带 $\log$ 的数据结构来维护，但是我们考虑用 分块 + 值域分块 的结构来均摊复杂度，就可以做到时空均为 $\mathcal{O}(n \sqrt n)$。如果每 $\sqrt n$ 次重构一下值域分块，甚至能够做到 $\mathcal{O}(n)$ 的优秀空间复杂度。

这种做法的可拓展性非常强，很多问题都可以使用类似这种方法解决。比如大名鼎鼎的最初分块！再比如 APIO2018 的巨大毒瘤 [P4632 新家](https://www.luogu.com.cn/problem/P4632)，就是用类似的方法转化来的。

这个做法还跟颜色段均摊能扯上关系，有时间可以写一点这方面的笔记。
