10.29 开始写/fendou

9 月份原本还有挺多数据结构要写的，结果只写了第二分块，后面都鸽了，大概率也不会去补。

## CF600E

> 给定一棵树，节点带颜色，求出每一棵子树内出现次数最多的颜色。
>
> $n \le 10^5$。

这个题不是线段树合并的板子吗。对每一个节点开一棵用来存储颜色的动态开点线段树，然后自底向上地合并就很容易求得答案。

当然，DSU on tree 也是可以做的，时空复杂度貌似都一样。

## CF609F

> 有 $n$ 只青蛙，第 $i$ 只青蛙位置是 $x_{i}$，舌头长 $t_{i}$，能够吃到 $[x_{i}, x_{i} + t_{i}]$ 的蚊子，保证青蛙的位置互不相同。
>
> 有 $m$ 只蚊子依次出现，第 $i$ 只蚊子的位置是 $p_{i}$，吃掉它青蛙的舌头会增长 $b_{i}$。蚊子会被能吃掉它的最左边的青蛙吃掉。只有当当前存在的所有蚊子都不能被吃掉时，下一只蚊子才会出现。
>
> 求每只青蛙最后吃掉的蚊子数量与舌头长度。
>
> $n, m \le 2 \times 10^5$，值域 $10^9$。

首先我们可以发现，如果存在某一只青蛙，其左侧的某一只青蛙能吃到的蚊子范围把它能吃到的范围覆盖了的话，那它永远也不会吃到蚊子。


那么我们就可以将青蛙按照 $x$ 排序，排完序之后，再通过类似双指针的方式删去没用的青蛙。做完之后我们会发现当前的青蛙的左右端点都是递增的。

在这样的条件下，判断一只蚊子会不会被吃以及被哪一只青蛙吃都是很简单的，直接在青蛙序列上二分即可。这启发我们考虑维护一个不存在无用青蛙的序列。这也是不难的，在第 $j$ 只蚊子被吃掉之后，我们可以考虑删除当前所有右端点位于 $[x_{i} + t_{i}, x_{i} + t_{i} + b_{j}]$ 之间的青蛙，其中 $i$ 是吃掉这只蚊子的青蛙编号。不过还要注意的是，在青蛙吃掉蚊子后，舌头会变长，可能会~~引发链式反应~~吃掉更多的蚊子，需要特别处理。

那么只需要用 `std::set` 维护一棵平衡树即可，或者 `std::vector` 维护一棵伪平衡树（

## CF620E

> 一棵 $n$ 个节点带颜色的有根树，根节点是 $1$，有两种操作共 $m$ 次：
>
> 1. `1 u c`：将以 $u$ 为根的子树中所有节点的颜色改为 $c$。
> 2. `2 u`：查询 $u$ 子树中的颜色数目。
>
> $n, m \le 4 \times 10^5$，$c \le 60$。

我们注意到它只有六十种颜色，那么开六十棵线段树然后套个树剖就做完了。

## CF628E

> 一个 $n$ 行 $m$ 列的由 `z` 与 `.` 构成的字符矩阵，问矩阵中由 `z` 构成的 Z 字形的数量。
>
> $n, m \le 3000$。

挺妙的题。

首先 $\mathcal{O}(n^3)$ 肯定是会做的。我们可以 $\mathcal{O}(n^2)$ 预处理出从每一个点出发的极长的向左的、向右的以及向左下方的 `z` 的长度，然后 $\mathcal{O}(n^2)$ 枚举拐点，每个点再 $\mathcal{O}(n)$ 统计合法的 Z 形即可。

考虑如何优化这个过程。我们发现，上边这个算法的复杂度瓶颈在于每次都需要花 $\mathcal{O}(n)$ 的时间去枚举当前点左下方的点，然后判断它向右的极长的 `z` 的长度是否超过了当前点。

不难发现这可以抽象成一个偏序问题。条件有二：

1. 与当前枚举的点在同一条对角线上，且位于当前点的左下方，并且未超出当前点向左下的极长的 `z` 的范围（即保证连续）;
2. 其极长右端点要超过当前点的横坐标。

那么这就是一个比较朴素的数点了。我们对每一条对角线开一个 BIT，然后倒着枚举横坐标就可以免撤销地统计贡献。

## CF678F

> 有 3 种操作共 $n$ 次：
>
> 1. 向当前集合添加一条斜率为 $x$，截距为 $y$ 的一次函数；
> 2. 删除之前某次操作添加的一次函数；
> 3. 求当前集合内函数在某一给定横坐标处的最大值。
>
> $n \le 3 \times 10^5$，值域 $[10^{-9}, 10^9]$。

如果没有删除操作，那这就是一个李超树的板子题，大家都会做。

我们发现，李超树上的删除操作不是很好处理，但是撤消某一次操作是容易的，这启发我们使用线段树分治来解决问题。

具体来说，我们考虑在时间轴上建线段树，对线段树的每个节点维护一棵动态开点的李超树。按照套路，我们将某一个一次函数存在的时间范围拆成时间轴线段树上的 $\mathcal{O}(\log n)$ 个节点，然后在这些节点上插入当前的一次函数。对于询问，不难发现只有这个时间点对应的李超树到时间轴线段树根节点上的李超树一共 $\mathcal{O}(\log n)$ 棵李超树是有用的，那么在对应的李超树上查询即可。

插入与查询的时间复杂度不需多言，均为 $\mathcal{O}(\log^2 n)$。主要得说一下为啥这样做的空间复杂度为 $\mathcal{O}(n \log n)$。我们知道，普通的动态开点线段树插入某一个值会新建 $\mathcal{O}(\log n)$ 个节点，但李超线段树与普通的动态开点树的一个很大的不同就是，李超树采用了**标记永久化**的思想，这使得李超树上的非叶子节点也可以储存信息。那么，如果在李超树的插入过程中遇到了空节点，我们就可以将当前线段作为这个新节点的标记，然后立即返回。这样，每次插入最多会在李超树上插入**一个**节点，而每条线段会被插入 $\mathcal{O}(\log n)$ 次，那么总体的空间复杂度为 $\mathcal{O}(n \log n)$。

做的时候感觉非常牛逼，做完之后感觉其实挺套路的？

## CF762E

> 有 $n$ 个点，每个点有 $x, r, f$ 三种属性。求满足以下几个条件的点对 $(i, j)$ 的数量：
>
> + $|f_{i} - f_{j}| \le k$；
> + $|x_{i} - x_{j}| \le \min(r_{i}, r_{j})$；
> + $i < j$。
>
> $n \le 10^5$。

这种题看起来就挺 CDQ 分治的。

我们发现主要不好处理的是第二个约束中的这个 $\min$。于是我们可以考虑将其拆成额外的两个约束，即 $r_{j} \le r_{i}$ 且 $|x_{i} - x_{j}| \le r_{j}$。那么我们先按 $r$ 排序，就可以满足前边那个玩意了。

第一个有关 $f$ 与 $k$ 的式子显然可以分治再加上双指针，而我们拆出来的那个剩下的式子也很显然是一个一维数点。于是我们考虑 CDQ 分治满足第一个式子，再拿 BIT 数一下点就做完了。

时间复杂度 $\mathcal{O}(n \log^2 n)$。

## CF803G

> 序列 $a$ 是由序列 $b$ 拼接 $k$ 次得到的，其中 $b$ 与 $k$ 给定。写一个数据结构支持 $a$ 序列上区间查询最小值与区间推平。
>
> $n, q \le 10^5$，$k \le 10^4$，值域 $10^9$。

感觉，挺经典的。

首先 $n \cdot k$ 有 $10^9$，那么肯定是考虑动态开点线段树。现在主要是考虑如何新建节点与下传标记。

我们发现只有在做区间推平的时候，新建的节点的值才会与 $b$ 中的对应值不同，那么我们可以考虑将新建的节点初始化为 $b$ 的区间中的对应值，这个可以用 ST 表做。

下传标记好像就跟常规的线段树差不多了。

## CF817F

> 维护一个初始为空的集合，三种操作共 $n$ 次：
>
> 1. 把 $[l,r]$ 中在集合中没有出现过的数添加到集合中。
> 2. 把 $[l,r]$ 中在集合中出现过的数从集合中删掉。
> 3. 把 $[l,r]$ 中在集合中没有出现过的数添加到集合中，并把 $[l,r]$ 中在集合中出现过的数从集合中删掉。
>
> 每次操作后输出当前集合的 MEX（注意，从 $1$ 开始）。
>
> $n \le 10^5$，值域 $10^{18}$。

很容易发现这其实就是在做 $01$ 序列上的区间复制与区间反转，那么好像可以直接拍一个动态开点线段树，查询就是在线段树上二分最左端的为 $0$ 的点。

然后发现值域有点逆天，这题只给了 256MB 的空间，如果直接动态开点的话显然吃不消。于是考虑加个离散化就行了。

这里说一下对于这类问题，正确的离散化方法是将所有区间的左右端点，右端点加一，与值域的最小值加入离散化数组中。正确性不难证明。

## CF837G

> 给出 $n$ 个函数，第 $i$ 个函数形如：
> $$
f_{i}(x)=
\begin{cases}
y_{1}  & x \le x_{1}         \\
ax + b & x_{1} < x \le x_{2} \\
y_{2}  & x > x_{2}           \\
\end{cases}
> $$
> $m$ 次操作，每次操作给定 $l, r, x$，求 $\sum_{l \le i \le r} f_{i}(x)$。强制在线。
>
> $n \le 7.5 \times 10^4$，$m \le 5 \times 10^5$，值域 $10^9$。

额，很容易发现其实每个函数都是一个分三段的一次函数，只不过前后两端的斜率为 $0$。

那好像直接拍个可持久化线段树维护一下斜率与截距的和就做完了。不过动态开点不是很好区间赋值，但注意到这题是单点查询，于是可以转成查分序列，然后就变成了单点修改 + 区间查询，然后就做完了。

## CF863E

> 给定一些线段，查询是否存在某条线段被其他线段完全覆盖。
>
> $n \le 2 \times 20^5$，值域 $10^9$。

最简单的一集，直接离散化然后拍个树状数组就做完了。
